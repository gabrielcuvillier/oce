// This file has been automatically generated from resource file src/Shaders/DeclarationsImpl.glsl

static const char Shaders_DeclarationsImpl_glsl[] =
 "#if defined(FRAGMENT_SHADER)\n"
 "void occSetFragColor (in vec4 theColor)\n"
 "{\n"
 "#if defined(OCC_ALPHA_TEST)\n"
 "if (theColor.a < occAlphaCutoff) discard;\n"
 "#endif\n"
 "#if defined(OCC_WRITE_WEIGHT_OIT_COVERAGE)\n"
 "float aWeight = theColor.a * clamp (1e+2 * pow (1.0 - gl_FragCoord.z * occOitDepthFactor, 3.0), 1e-2, 1e+2);\n"
 "occFragCoverage.r = theColor.a * aWeight;\n"
 "occFragColor = vec4 (theColor.rgb * theColor.a * aWeight, theColor.a);\n"
 "#else\n"
 "occFragColor = theColor;\n"
 "#endif\n"
 "}\n"
 "#endif\n"
 "#if defined(THE_MAX_LIGHTS) && (THE_MAX_LIGHTS > 0)\n"
 "uniform THE_PREC_ENUM ivec2 occLightSourcesTypes[THE_MAX_LIGHTS];\n"
 "uniform vec4 occLightSources[THE_MAX_LIGHTS * 4];\n"
 "#if !defined(HAVE_WEBGL)\n"
 "int occLight_Type (in int theId) { return occLightSourcesTypes[theId].x; }\n"
 "int occLight_IsHeadlight (in int theId) { return occLightSourcesTypes[theId].y; }\n"
 "vec4 occLight_Diffuse (in int theId) { return occLightSources[theId * 4 + 0]; }\n"
 "vec4 occLight_Specular (in int theId) { return occLightSources[theId * 4 + 0]; }\n"
 "vec4 occLight_Position (in int theId) { return occLightSources[theId * 4 + 1]; }\n"
 "vec4 occLight_SpotDirection (in int theId) { return occLightSources[theId * 4 + 2]; }\n"
 "float occLight_ConstAttenuation (in int theId) { return occLightSources[theId * 4 + 3].x; }\n"
 "float occLight_LinearAttenuation (in int theId) { return occLightSources[theId * 4 + 3].y; }\n"
 "float occLight_SpotCutOff (in int theId) { return occLightSources[theId * 4 + 3].z; }\n"
 "float occLight_SpotExponent (in int theId) { return occLightSources[theId * 4 + 3].w; }\n"
 "#else\n"
 "int occLight_Type (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSourcesTypes[x].x; } } }\n"
 "int occLight_IsHeadlight (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSourcesTypes[x].y; } } }\n"
 "vec4 occLight_Diffuse (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSources[x * 4 + 0]; }} }\n"
 "vec4 occLight_Specular (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSources[x * 4 + 0]; }} }\n"
 "vec4 occLight_Position (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSources[x * 4 + 1]; }} }\n"
 "vec4 occLight_SpotDirection (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSources[x * 4 + 2]; }} }\n"
 "float occLight_ConstAttenuation (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSources[x * 4 + 3].x; }} }\n"
 "float occLight_LinearAttenuation (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSources[x * 4 + 3].y; }} }\n"
 "float occLight_SpotCutOff (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSources[x * 4 + 3].z; }} }\n"
 "float occLight_SpotExponent (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSources[x * 4 + 3].w; }} }\n"
 "#endif\n"
 "#endif\n"
 "uniform vec4 occFrontMaterial[5];\n"
 "uniform vec4 occBackMaterial[5];\n"
 "vec4 occFrontMaterial_Ambient(void) { return occFrontMaterial[0]; }\n"
 "vec4 occFrontMaterial_Diffuse(void) { return occFrontMaterial[1]; }\n"
 "vec4 occFrontMaterial_Specular(void) { return occFrontMaterial[2]; }\n"
 "vec4 occFrontMaterial_Emission(void) { return occFrontMaterial[3]; }\n"
 "float occFrontMaterial_Shininess(void) { return occFrontMaterial[4].x; }\n"
 "float occFrontMaterial_Transparency(void) { return occFrontMaterial[4].y; }\n"
 "vec4 occBackMaterial_Ambient(void) { return occBackMaterial[0]; }\n"
 "vec4 occBackMaterial_Diffuse(void) { return occBackMaterial[1]; }\n"
 "vec4 occBackMaterial_Specular(void) { return occBackMaterial[2]; }\n"
 "vec4 occBackMaterial_Emission(void) { return occBackMaterial[3]; }\n"
 "float occBackMaterial_Shininess(void) { return occBackMaterial[4].x; }\n"
 "float occBackMaterial_Transparency(void) { return occBackMaterial[4].y; }\n"
 "vec2 occTextureTrsf_Translation(void) { return occTexTrsf2d[0].xy; }\n"
 "vec2 occTextureTrsf_Scale(void) { return occTexTrsf2d[0].zw; }\n"
 "float occTextureTrsf_RotationSin(void) { return occTexTrsf2d[1].x; }\n"
 "float occTextureTrsf_RotationCos(void) { return occTexTrsf2d[1].y; }\n";
