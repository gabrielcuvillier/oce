// This file has been automatically generated from resource file src/Shaders/DeclarationsImpl.glsl

static const char Shaders_DeclarationsImpl_glsl[] =
  "// arrays of light sources\n"
  "uniform THE_PREC_ENUM ivec2 occLightSourcesTypes[THE_MAX_LIGHTS]; //!< packed light sources types\n"
  "uniform               vec4  occLightSources[THE_MAX_LIGHTS * 4];  //!< packed light sources parameters\n"
  "\n"
  "// light source properties accessors\n"
  "// GAB Note: hacked for shader to work on WebGL (array indices must be constant expressions)\n"
  "int   occLight_Type              (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSourcesTypes[x].x; } } }\n"
  "int   occLight_IsHeadlight       (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSourcesTypes[x].y; } } }\n"
  "vec4  occLight_Diffuse           (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSources[x * 4 + 0]; }} }\n"
  "vec4  occLight_Specular          (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSources[x * 4 + 0]; }} }\n"
  "vec4  occLight_Position          (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSources[x * 4 + 1]; }} }\n"
  "vec4  occLight_SpotDirection     (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSources[x * 4 + 2]; }} }\n"
  "float occLight_ConstAttenuation  (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSources[x * 4 + 3].x; }} }\n"
  "float occLight_LinearAttenuation (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSources[x * 4 + 3].y; }} }\n"
  "float occLight_SpotCutOff        (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSources[x * 4 + 3].z; }} }\n"
  "float occLight_SpotExponent      (in int theId) { for (int x = 0; x < THE_MAX_LIGHTS; x++) { if (x == theId) { return occLightSources[x * 4 + 3].w; }} }\n"
  "\n"
  "// material state\n"
  "uniform vec4 occFrontMaterial[5];\n"
  "uniform vec4 occBackMaterial[5];\n"
  "\n"
  "// front material properties accessors\n"
  "vec4  occFrontMaterial_Ambient(void)      { return occFrontMaterial[0]; }\n"
  "vec4  occFrontMaterial_Diffuse(void)      { return occFrontMaterial[1]; }\n"
  "vec4  occFrontMaterial_Specular(void)     { return occFrontMaterial[2]; }\n"
  "vec4  occFrontMaterial_Emission(void)     { return occFrontMaterial[3]; }\n"
  "float occFrontMaterial_Shininess(void)    { return occFrontMaterial[4].x; }\n"
  "float occFrontMaterial_Transparency(void) { return occFrontMaterial[4].y; }\n"
  "\n"
  "// back material properties accessors\n"
  "vec4  occBackMaterial_Ambient(void)       { return occBackMaterial[0]; }\n"
  "vec4  occBackMaterial_Diffuse(void)       { return occBackMaterial[1]; }\n"
  "vec4  occBackMaterial_Specular(void)      { return occBackMaterial[2]; }\n"
  "vec4  occBackMaterial_Emission(void)      { return occBackMaterial[3]; }\n"
  "float occBackMaterial_Shininess(void)     { return occBackMaterial[4].x; }\n"
  "float occBackMaterial_Transparency(void)  { return occBackMaterial[4].y; }\n"
  "\n"
  "// 2D texture coordinates transformation\n"
  "vec2  occTextureTrsf_Translation(void) { return occTexTrsf2d[0].xy; }\n"
  "vec2  occTextureTrsf_Scale(void)       { return occTexTrsf2d[0].zw; }\n"
  "float occTextureTrsf_RotationSin(void) { return occTexTrsf2d[1].x; }\n"
  "float occTextureTrsf_RotationCos(void) { return occTexTrsf2d[1].y; }\n";
